<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Architecture - Redis Operator</title>
  <meta name="description" content="Architecture and internals of the Redis Operator">
  <link rel="stylesheet" href="assets/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#128736;</text></svg>">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <a href="index.html" class="logo">
        <svg viewBox="0 0 32 32" fill="currentColor">
          <path d="M16 0C7.163 0 0 7.163 0 16s7.163 16 16 16 16-7.163 16-16S24.837 0 16 0zm0 4c6.627 0 12 5.373 12 12s-5.373 12-12 12S4 22.627 4 16 9.373 4 16 4zm-2 6v4h-4v4h4v4h4v-4h4v-4h-4v-4h-4z"/>
        </svg>
        Redis Operator
      </a>
      <nav class="nav">
        <a href="index.html">Home</a>
        <a href="getting-started.html">Getting Started</a>
        <a href="configuration.html">Configuration</a>
        <a href="architecture.html" class="active">Architecture</a>
      </nav>
      <a href="https://github.com/troke12/redis-operator" class="github-link" target="_blank">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
        </svg>
        GitHub
      </a>
    </div>
  </header>

  <!-- Content -->
  <div class="container">
    <div class="doc-content">
      <h1>Architecture</h1>
      <p class="subtitle">Understand how the Redis Operator works internally</p>

      <h2>Overview</h2>
      <p>
        The Redis Operator is a Kubernetes controller that manages the lifecycle of Redis Cluster deployments.
        It follows the operator pattern, using custom resources to define the desired state and continuously
        reconciling the actual state to match.
      </p>

      <div class="alert alert-info">
        <span class="alert-icon">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="16" x2="12" y2="12"/>
            <line x1="12" y1="8" x2="12.01" y2="8"/>
          </svg>
        </span>
        <div>
          The operator is built using the Kubernetes controller-runtime library and follows
          best practices for Kubernetes operators.
        </div>
      </div>

      <h2>Components</h2>

      <h3>1. RedisCluster CRD</h3>
      <p>
        The Custom Resource Definition (CRD) extends the Kubernetes API with a new resource type:
        <code>RedisCluster</code>. This resource describes the desired state of your Redis cluster.
      </p>
      <pre><code>apiVersion: redis.redis-operator.io/v1alpha1
kind: RedisCluster
metadata:
  name: redis-cluster
spec:
  replicas: 3
  autoRebalance: true
  serviceName: redis-headless
  statefulSetName: redis
  passwordSecretRef:
    name: redis-auth
    key: REDIS_PASSWORD</code></pre>

      <h3>2. Controller</h3>
      <p>
        The controller is the core component that watches RedisCluster resources and reconciles
        the cluster state. It handles:
      </p>
      <ul>
        <li><strong>Cluster Bootstrap:</strong> Initializes a new Redis cluster when pods are ready</li>
        <li><strong>Scale Up:</strong> Adds new nodes to the cluster and rebalances slots</li>
        <li><strong>Scale Down:</strong> Safely removes nodes, migrating data first</li>
        <li><strong>Health Monitoring:</strong> Continuously checks cluster health</li>
        <li><strong>Failure Recovery:</strong> Handles node failures and cluster state issues</li>
      </ul>

      <h3>3. Redis CLI Runner</h3>
      <p>
        The operator executes Redis commands using <code>kubectl exec</code> to run
        <code>redis-cli</code> commands inside the Redis pods. This approach:
      </p>
      <ul>
        <li>Avoids network complexity by using pod exec</li>
        <li>Works with any network policy configuration</li>
        <li>Supports password authentication</li>
        <li>Provides reliable command execution with proper error handling</li>
      </ul>

      <h3>4. Kubernetes Resources</h3>
      <p>The operator manages and interacts with these Kubernetes resources:</p>
      <ul>
        <li><strong>StatefulSet:</strong> Manages Redis pod lifecycle with stable identities</li>
        <li><strong>Headless Service:</strong> Provides DNS-based pod discovery</li>
        <li><strong>ConfigMap:</strong> Stores Redis configuration</li>
        <li><strong>Secret:</strong> Stores the Redis password</li>
        <li><strong>PodDisruptionBudget:</strong> Ensures cluster availability during updates</li>
      </ul>

      <h2>Reconciliation Flow</h2>
      <p>The controller follows this reconciliation loop:</p>

      <h3>Phase 1: Discovery</h3>
      <ol>
        <li>Fetch the RedisCluster resource</li>
        <li>Get the associated StatefulSet</li>
        <li>List all Redis pods and their states</li>
        <li>Retrieve the password from the Secret</li>
      </ol>

      <h3>Phase 2: Cluster State Assessment</h3>
      <ol>
        <li>Execute <code>CLUSTER INFO</code> on a healthy node</li>
        <li>Execute <code>CLUSTER NODES</code> to get the current topology</li>
        <li>Compare actual nodes with expected pod list</li>
        <li>Identify any missing, extra, or failed nodes</li>
      </ol>

      <h3>Phase 3: Action Determination</h3>
      <p>Based on the assessment, the controller determines the required action:</p>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th>Condition</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>No cluster exists, enough pods ready</td>
              <td>Bootstrap cluster</td>
            </tr>
            <tr>
              <td>New pods not in cluster</td>
              <td>Add nodes (scale up)</td>
            </tr>
            <tr>
              <td>More cluster nodes than pods</td>
              <td>Remove nodes (scale down)</td>
            </tr>
            <tr>
              <td>Failed nodes detected</td>
              <td>Forget and recover</td>
            </tr>
            <tr>
              <td>Cluster state is OK</td>
              <td>No action needed</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>Phase 4: Execution</h3>
      <p>The controller executes the required Redis commands:</p>
      <ul>
        <li><code>CLUSTER MEET</code> - Add a new node</li>
        <li><code>CLUSTER ADDSLOTS</code> - Assign slots during bootstrap</li>
        <li><code>CLUSTER REBALANCE</code> - Redistribute slots</li>
        <li><code>CLUSTER FORGET</code> - Remove a node from the cluster</li>
        <li><code>CLUSTER FAILOVER</code> - Promote a replica to master</li>
      </ul>

      <h3>Phase 5: Status Update</h3>
      <p>Finally, the controller updates the RedisCluster status:</p>
      <pre><code>status:
  phase: Ready
  clusterState: ok
  nodes: 3
  message: "Cluster is healthy with 3 nodes"</code></pre>

      <h2>Cluster Operations</h2>

      <h3>Bootstrap</h3>
      <p>When a new cluster is created:</p>
      <ol>
        <li>Wait for <code>minReady</code> pods to be running and ready</li>
        <li>Create the cluster using <code>CLUSTER MEET</code> commands</li>
        <li>Distribute 16384 hash slots evenly across master nodes</li>
        <li>Update status to <code>Ready</code></li>
      </ol>

      <h3>Scale Up</h3>
      <p>When new pods are added:</p>
      <ol>
        <li>Detect new pods not in the cluster</li>
        <li>Add each new node using <code>CLUSTER MEET</code></li>
        <li>Optionally rebalance slots if <code>autoRebalance</code> is enabled</li>
        <li>Update the cluster node count</li>
      </ol>

      <h3>Scale Down</h3>
      <p>When pods are removed:</p>
      <ol>
        <li>Identify nodes to be removed (highest ordinal pods)</li>
        <li>If the node is a master with slots, migrate slots to other masters</li>
        <li>Issue <code>CLUSTER FORGET</code> on all remaining nodes</li>
        <li>Update the cluster configuration</li>
      </ol>

      <div class="alert alert-warning">
        <span class="alert-icon">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
            <line x1="12" y1="9" x2="12" y2="13"/>
            <line x1="12" y1="17" x2="12.01" y2="17"/>
          </svg>
        </span>
        <div>
          <strong>Important:</strong> Always maintain at least 3 nodes in the cluster.
          Redis Cluster requires a minimum of 3 master nodes to function properly.
        </div>
      </div>

      <h2>DNS-Based Addressing</h2>
      <p>
        The operator uses hostname-based cluster announcement, a feature available in Redis 6.2+.
        This provides stable addressing even when pod IPs change.
      </p>

      <h3>How It Works</h3>
      <ol>
        <li>Each Redis pod has a stable DNS name: <code>redis-0.redis-headless.namespace.svc.cluster.local</code></li>
        <li>Redis is configured with <code>cluster-announce-hostname</code> to advertise this DNS name</li>
        <li>Cluster nodes communicate using hostnames instead of IP addresses</li>
        <li>When a pod restarts with a new IP, the cluster continues to function</li>
      </ol>

      <h3>Redis Configuration</h3>
      <pre><code># Hostname-based announcement (Redis 6.2+)
cluster-announce-hostname ${HOSTNAME}.redis-headless.${NAMESPACE}.svc.cluster.local
cluster-preferred-endpoint-type hostname</code></pre>

      <h2>High Availability</h2>

      <h3>Pod Disruption Budget</h3>
      <p>
        The chart includes a PodDisruptionBudget to ensure cluster availability during
        voluntary disruptions like node drains or upgrades:
      </p>
      <pre><code>apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: redis-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: redis</code></pre>

      <h3>Failure Recovery</h3>
      <p>The operator handles node failures by:</p>
      <ol>
        <li>Detecting failed nodes via <code>CLUSTER NODES</code> (nodes marked as <code>fail</code>)</li>
        <li>Issuing <code>CLUSTER FORGET</code> to remove the failed node from cluster topology</li>
        <li>Allowing Kubernetes to reschedule the failed pod</li>
        <li>Automatically adding the recovered pod back to the cluster</li>
      </ol>

      <h2>Security</h2>

      <h3>Password Authentication</h3>
      <p>
        The operator supports Redis password authentication using Kubernetes Secrets:
      </p>
      <ol>
        <li>Password is stored in a Kubernetes Secret</li>
        <li>Redis pods read the password from the Secret</li>
        <li>The operator retrieves the password for <code>redis-cli</code> commands</li>
        <li>All cluster communication is authenticated</li>
      </ol>

      <h3>RBAC</h3>
      <p>The operator requires specific RBAC permissions:</p>
      <ul>
        <li><strong>RedisCluster:</strong> Full access to manage custom resources</li>
        <li><strong>Pods:</strong> List, get, and exec for running redis-cli</li>
        <li><strong>StatefulSets:</strong> Get to read replica count</li>
        <li><strong>Secrets:</strong> Get to read the password</li>
        <li><strong>Events:</strong> Create to emit cluster events</li>
      </ul>

      <h2>Monitoring</h2>

      <h3>Status Conditions</h3>
      <p>Monitor the RedisCluster status:</p>
      <pre><code>kubectl get rediscluster redis-cluster -o yaml</code></pre>

      <h3>Operator Logs</h3>
      <p>Check operator logs for detailed reconciliation information:</p>
      <pre><code>kubectl logs -f deployment/redis-operator-controller-manager -n redis-operator</code></pre>

      <h3>Redis Cluster Info</h3>
      <p>Verify cluster state directly:</p>
      <pre><code># Get cluster info
kubectl exec -it redis-0 -n redis-operator -- \
  redis-cli -a $PASSWORD cluster info

# Get cluster nodes
kubectl exec -it redis-0 -n redis-operator -- \
  redis-cli -a $PASSWORD cluster nodes</code></pre>

      <h2>Next Steps</h2>
      <ul>
        <li><a href="getting-started.html">Getting Started</a> - Install and run your first cluster</li>
        <li><a href="configuration.html">Configuration</a> - Customize your deployment</li>
      </ul>
    </div>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <p>
      Redis Operator is open source software licensed under the MIT License.
      <br>
      Maintained by <a href="https://github.com/troke12" target="_blank">troke12</a>
    </p>
  </footer>
</body>
</html>
